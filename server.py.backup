#!/usr/bin/env python3
"""
SlideGen Pro - Backend Server with Authentication & Subscriptions
Supports user authentication, subscription management, and presentation generation.
"""

from flask import Flask, request, jsonify, session
from flask_cors import CORS
import os
import json
import requests
from datetime import datetime, timedelta
import logging
import sqlite3
import hashlib
import secrets
from functools import wraps

app = Flask(__name__)
app.secret_key = os.environ.get('SECRET_KEY', secrets.token_hex(32))
CORS(app, supports_credentials=True, origins=["http://localhost:3000", "http://127.0.0.1:3000"])

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Anthropic API configuration
ANTHROPIC_API_KEY = os.environ.get('ANTHROPIC_API_KEY')
ANTHROPIC_API_URL = "https://api.anthropic.com/v1/messages"
MODEL = "claude-sonnet-4-20250514"

# Database initialization
DB_PATH = 'slidegen.db'

def init_db():
    """Initialize the database with required tables"""
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()
    
    # Users table
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS users (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            email TEXT UNIQUE NOT NULL,
            password_hash TEXT NOT NULL,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            subscription_status TEXT DEFAULT 'free',
            subscription_expires TIMESTAMP,
            generations_used INTEGER DEFAULT 0,
            generations_limit INTEGER DEFAULT 1,
            last_reset TIMESTAMP
        )
    ''')
    
    # Presentations table
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS presentations (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id INTEGER NOT NULL,
            title TEXT NOT NULL,
            topic TEXT NOT NULL,
            num_slides INTEGER NOT NULL,
            theme TEXT NOT NULL,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (user_id) REFERENCES users (id)
        )
    ''')
    
    # Rate limiting table
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS rate_limits (
            user_id INTEGER NOT NULL,
            endpoint TEXT NOT NULL,
            request_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (user_id) REFERENCES users (id)
        )
    ''')
    
    conn.commit()
    conn.close()
    logger.info("Database initialized successfully")

# Initialize database on startup
init_db()

def hash_password(password):
    """Hash a password using SHA-256"""
    return hashlib.sha256(password.encode()).hexdigest()

def get_db():
    """Get database connection"""
    conn = sqlite3.connect(DB_PATH)
    conn.row_factory = sqlite3.Row
    return conn

def login_required(f):
    """Decorator to require login for endpoints"""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if 'user_id' not in session:
            return jsonify({'error': 'Authentication required'}), 401
        return f(*args, **kwargs)
    return decorated_function

def check_generations_limit(user_id):
    """Check if user has generations available"""
    conn = get_db()
    cursor = conn.cursor()
    
    user = cursor.execute('SELECT * FROM users WHERE id = ?', (user_id,)).fetchone()
    conn.close()
    
    if not user:
        return False
    
    # Check if we need to reset monthly limit
    last_reset = datetime.fromisoformat(user['last_reset']) if user['last_reset'] else None
    now = datetime.now()
    
    if user['subscription_status'] == 'premium':
        # Reset monthly if it's a new month
        if not last_reset or (now.year > last_reset.year or now.month > last_reset.month):
            conn = get_db()
            cursor = conn.cursor()
            cursor.execute('''
                UPDATE users 
                SET generations_used = 0, last_reset = ? 
                WHERE id = ?
            ''', (now.isoformat(), user_id))
            conn.commit()
            conn.close()
            return True
    
    return user['generations_used'] < user['generations_limit']

def increment_generation_count(user_id):
    """Increment user's generation count"""
    conn = get_db()
    cursor = conn.cursor()
    cursor.execute('''
        UPDATE users 
        SET generations_used = generations_used + 1 
        WHERE id = ?
    ''', (user_id,))
    conn.commit()
    conn.close()

def check_rate_limit(user_id, endpoint, limit=20, window_minutes=1):
    """Check rate limiting for user"""
    conn = get_db()
    cursor = conn.cursor()
    
    cutoff = (datetime.now() - timedelta(minutes=window_minutes)).isoformat()
    
    count = cursor.execute('''
        SELECT COUNT(*) as count FROM rate_limits 
        WHERE user_id = ? AND endpoint = ? AND request_time > ?
    ''', (user_id, endpoint, cutoff)).fetchone()['count']
    
    if count >= limit:
        conn.close()
        return False
    
    # Log this request
    cursor.execute('''
        INSERT INTO rate_limits (user_id, endpoint) VALUES (?, ?)
    ''', (user_id, endpoint))
    
    conn.commit()
    conn.close()
    return True

def call_anthropic(prompt, max_tokens=2000):
    """Make API call to Anthropic"""
    if not ANTHROPIC_API_KEY:
        raise Exception("ANTHROPIC_API_KEY environment variable not set")
    
    try:
        headers = {
            "x-api-key": ANTHROPIC_API_KEY,
            "anthropic-version": "2023-06-01",
            "content-type": "application/json"
        }
        
        payload = {
            "model": MODEL,
            "max_tokens": max_tokens,
            "messages": [{"role": "user", "content": prompt}]
        }
        
        response = requests.post(ANTHROPIC_API_URL, headers=headers, json=payload, timeout=60)
        
        if response.status_code == 200:
            data = response.json()
            return data['content'][0]['text']
        else:
            raise Exception(f"API error: {response.status_code} - {response.text}")
    
    except Exception as e:
        logger.error(f"Anthropic API error: {str(e)}")
        raise

# ============= Authentication Endpoints =============

@app.route('/api/auth/signup', methods=['POST'])
def signup():
    """Create new user account with 1 free presentation"""
    try:
        data = request.json
        email = data.get('email', '').strip().lower()
        password = data.get('password', '')
        
        if not email or not password:
            return jsonify({'error': 'Email and password required'}), 400
        
        if len(password) < 6:
            return jsonify({'error': 'Password must be at least 6 characters'}), 400
        
        conn = get_db()
        cursor = conn.cursor()
        
        # Check if email exists
        existing = cursor.execute('SELECT id FROM users WHERE email = ?', (email,)).fetchone()
        if existing:
            conn.close()
            return jsonify({'error': 'Email already registered'}), 400
        
        # Create user with 1 free generation
        password_hash = hash_password(password)
        cursor.execute('''
            INSERT INTO users (email, password_hash, subscription_status, generations_limit, last_reset)
            VALUES (?, ?, 'free', 1, ?)
        ''', (email, password_hash, datetime.now().isoformat()))
        
        user_id = cursor.lastrowid
        conn.commit()
        conn.close()
        
        # Log user in
        session['user_id'] = user_id
        session['email'] = email
        
        logger.info(f"New user registered: {email}")
        return jsonify({
            'success': True,
            'message': 'Account created! You have 1 free presentation.',
            'user': {
                'id': user_id,
                'email': email,
                'subscription_status': 'free',
                'generations_used': 0,
                'generations_limit': 1
            }
        })
    
    except Exception as e:
        logger.error(f"Signup error: {str(e)}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/auth/login', methods=['POST'])
def login():
    """User login"""
    try:
        data = request.json
        email = data.get('email', '').strip().lower()
        password = data.get('password', '')
        
        if not email or not password:
            return jsonify({'error': 'Email and password required'}), 400
        
        conn = get_db()
        cursor = conn.cursor()
        
        user = cursor.execute('''
            SELECT * FROM users WHERE email = ? AND password_hash = ?
        ''', (email, hash_password(password))).fetchone()
        
        conn.close()
        
        if not user:
            return jsonify({'error': 'Invalid email or password'}), 401
        
        # Log user in
        session['user_id'] = user['id']
        session['email'] = user['email']
        
        logger.info(f"User logged in: {email}")
        return jsonify({
            'success': True,
            'user': {
                'id': user['id'],
                'email': user['email'],
                'subscription_status': user['subscription_status'],
                'generations_used': user['generations_used'],
                'generations_limit': user['generations_limit']
            }
        })
    
    except Exception as e:
        logger.error(f"Login error: {str(e)}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/auth/logout', methods=['POST'])
def logout():
    """User logout"""
    session.clear()
    return jsonify({'success': True})

@app.route('/api/auth/me', methods=['GET'])
@login_required
def get_current_user():
    """Get current user info"""
    try:
        conn = get_db()
        cursor = conn.cursor()
        
        user = cursor.execute('SELECT * FROM users WHERE id = ?', (session['user_id'],)).fetchone()
        conn.close()
        
        if not user:
            return jsonify({'error': 'User not found'}), 404
        
        # Check if monthly reset needed
        check_generations_limit(user['id'])
        
        # Refetch user after potential reset
        conn = get_db()
        user = conn.cursor().execute('SELECT * FROM users WHERE id = ?', (session['user_id'],)).fetchone()
        conn.close()
        
        return jsonify({
            'user': {
                'id': user['id'],
                'email': user['email'],
                'subscription_status': user['subscription_status'],
                'generations_used': user['generations_used'],
                'generations_limit': user['generations_limit'],
                'generations_remaining': user['generations_limit'] - user['generations_used']
            }
        })
    
    except Exception as e:
        logger.error(f"Get user error: {str(e)}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/subscription/upgrade', methods=['POST'])
@login_required
def upgrade_subscription():
    """Upgrade to premium subscription - $9.99/month for 10 presentations"""
    try:
        # In production, integrate with Stripe or other payment processor
        # For now, simulate successful payment
        
        conn = get_db()
        cursor = conn.cursor()
        
        expires = datetime.now() + timedelta(days=30)
        
        cursor.execute('''
            UPDATE users 
            SET subscription_status = 'premium',
                subscription_expires = ?,
                generations_limit = 10,
                generations_used = 0,
                last_reset = ?
            WHERE id = ?
        ''', (expires.isoformat(), datetime.now().isoformat(), session['user_id']))
        
        conn.commit()
        conn.close()
        
        logger.info(f"User {session['email']} upgraded to premium")
        return jsonify({
            'success': True,
            'message': 'Upgraded to Premium! You now have 10 presentations per month.',
            'subscription_status': 'premium',
            'generations_limit': 10
        })
    
    except Exception as e:
        logger.error(f"Upgrade error: {str(e)}")
        return jsonify({'error': str(e)}), 500

# ============= Presentation Generation Endpoints =============

@app.route('/api/research', methods=['POST'])
@login_required
def research_topic():
    """Research a topic and create presentation outline"""
    try:
        user_id = session['user_id']
        
        # Check generations limit
        if not check_generations_limit(user_id):
            return jsonify({'error': 'Generation limit reached. Upgrade to premium for 10 presentations/month!'}), 403
        
        # Rate limiting
        if not check_rate_limit(user_id, 'research'):
            return jsonify({'error': 'Too many requests. Please wait a moment.'}), 429
        
        data = request.json
        topic = data.get('topic')
        num_slides = data.get('num_slides', 10)
        slide_format = data.get('slide_format', 'Detailed')
        
        if not topic:
            return jsonify({'error': 'Topic required'}), 400
        
        if num_slides > 20:
            return jsonify({'error': 'Maximum 20 slides allowed'}), 400
        
        logger.info(f"Research request from user {user_id}: {topic[:50]} (Format: {slide_format})")
        
        if slide_format == "Concise":
            format_instruction = """For each section provide:
- Title: Specific aspect (2-4 words)
- Facts: SHORT PHRASES ONLY - no complete sentences, no punctuation at end, max 8 words per fact (3-4 facts per section)

Example:
"Cloud computing cost reduction"
"Real-time data analytics capabilities"
"Enhanced security protocols"""
        else:
            format_instruction = """For each section provide:
- Title: Specific aspect (2-5 words)
- Facts: FULL SENTENCES with specific details, numbers, dates, examples (3-4 facts per section)

Example:
"Cloud computing reduces infrastructure costs by up to 40% annually"
"Real-time analytics enable instant decision-making across departments"
"Advanced encryption protects sensitive data with military-grade security"""
        
        prompt = f"""You are an expert researcher. Research this topic and create a detailed presentation outline:

TOPIC: {topic}

INSTRUCTIONS:
1. Use your ACTUAL KNOWLEDGE about this topic
2. Include REAL facts, statistics, dates, names, examples
3. Create {num_slides - 1} logical sections (excluding title slide)
4. Write SPECIFIC, DETAILED information

{format_instruction}

Respond ONLY with valid JSON (no markdown, no backticks):
{{
  "sections": [
    {{
      "title": "Section Title",
      "key_facts": [
        "First fact",
        "Second fact",
        "Third fact"
      ]
    }}
  ]
}}"""
        
        response = call_anthropic(prompt, max_tokens=3000)
        
        # Clean and parse response
        response = response.replace('```json\n', '').replace('\n```', '').replace('```', '').strip()
        data = json.loads(response)
        
        sections = []
        for section in data.get('sections', [])[:num_slides-1]:
            facts = section.get('key_facts', ['Information about the topic'])
            # If concise format, ensure no punctuation at end
            if slide_format == "Concise":
                facts = [f.rstrip('.,!?;:') for f in facts]
            sections.append({
                'title': section.get('title', 'Key Concept'),
                'facts': facts
            })
        
        return jsonify({'sections': sections})
    
    except json.JSONDecodeError as e:
        logger.error(f"JSON parse error: {str(e)}")
        return jsonify({'error': 'Failed to parse AI response'}), 500
    except Exception as e:
        logger.error(f"Research error: {str(e)}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/generate-content', methods=['POST'])
@login_required
def generate_content():
    """Generate slide content"""
    try:
        user_id = session['user_id']
        
        # Rate limiting
        if not check_rate_limit(user_id, 'generate-content'):
            return jsonify({'error': 'Too many requests'}), 429
        
        data = request.json
        section = data.get('section')
        slide_title = data.get('slide_title')
        slide_format = data.get('slide_format', 'Detailed')
        
        if not section or not slide_title:
            return jsonify({'error': 'Missing required fields'}), 400
        
        facts_text = '\n'.join(section.get('facts', [])[:4])
        
        if slide_format == "Concise":
            prompt = f"""Create 3-5 KEY WORDS or SHORT PHRASES (2-4 words each) for a slide titled "{slide_title}".

Key information:
{facts_text}

INSTRUCTIONS:
1. Use ONLY key words or very short phrases (2-4 words maximum)
2. NO complete sentences
3. Make them specific

Respond ONLY with valid JSON:
{{
  "bullets": ["Key phrase one", "Key phrase two", "Key phrase three"]
}}"""
        else:
            prompt = f"""Create 3-5 clear, informative FULL SENTENCE bullet points for a slide titled "{slide_title}".

Key information:
{facts_text}

INSTRUCTIONS:
1. Write in natural, conversational language
2. Include SPECIFIC details (numbers, dates, examples)
3. Keep bullets clear and concise (10-20 words each)

Respond ONLY with valid JSON:
{{
  "bullets": ["First informative bullet point", "Second clear bullet point"]
}}"""
        
        response = call_anthropic(prompt, max_tokens=1000)
        response = response.replace('```json\n', '').replace('\n```', '').replace('```', '').strip()
        result = json.loads(response)
        
        return jsonify({'bullets': result.get('bullets', section.get('facts', [])[:3])})
    
    except Exception as e:
        logger.error(f"Content generation error: {str(e)}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/generate-notes', methods=['POST'])
@login_required
def generate_notes():
    """Generate speaker notes"""
    try:
        user_id = session['user_id']
        
        # Rate limiting
        if not check_rate_limit(user_id, 'generate-notes'):
            return jsonify({'error': 'Too many requests'}), 429
        
        data = request.json
        section = data.get('section')
        style = data.get('style', 'Detailed')
        slide_title = data.get('slide_title')
        slide_num = data.get('slide_num', 1)
        slide_format = data.get('slide_format', 'Detailed')
        slide_content = data.get('slide_content', [])
        
        if not section or not slide_title:
            return jsonify({'error': 'Missing required fields'}), 400
        
        facts_text = '\n'.join(section.get('facts', []))
        slide_bullets = '\n'.join([f"• {item}" for item in slide_content]) if slide_content else ""
        
        if style == "Concise":
            style_instruction = "Create brief talking points (2-3 sentences)."
        elif style == "Full Explanation":
            style_instruction = "Create a natural, conversational narrative like a TED talk."
        else:
            style_instruction = "Create conversational guidance (4-6 sentences)."
        
        if slide_format == "Concise":
            format_instruction = f"The slide shows KEY WORDS: {slide_bullets}\nEXPLAIN each keyword with full context."
        else:
            format_instruction = f"The slide shows: {slide_bullets}\nELABORATE with additional details."
        
        prompt = f"""Write speaker notes for slide {slide_num} titled "{slide_title}".

{format_instruction}

Style: {style}
{style_instruction}

Generate the notes now (plain text, no JSON):"""
        
        response = call_anthropic(prompt, max_tokens=1200)
        
        return jsonify({'notes': response.strip()})
    
    except Exception as e:
        logger.error(f"Notes generation error: {str(e)}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/presentations/complete', methods=['POST'])
@login_required
def complete_presentation():
    """Mark presentation as complete and increment generation count"""
    try:
        user_id = session['user_id']
        data = request.json
        
        title = data.get('title', 'Untitled')
        topic = data.get('topic', '')
        num_slides = data.get('num_slides', 10)
        theme = data.get('theme', 'Default')
        
        # Increment generation count
        increment_generation_count(user_id)
        
        # Save presentation record
        conn = get_db()
        cursor = conn.cursor()
        cursor.execute('''
            INSERT INTO presentations (user_id, title, topic, num_slides, theme)
            VALUES (?, ?, ?, ?, ?)
        ''', (user_id, title, topic, num_slides, theme))
        presentation_id = cursor.lastrowid
        conn.commit()
        conn.close()
        
        logger.info(f"User {user_id} completed presentation: {title}")
        return jsonify({
            'success': True, 
            'message': 'Presentation generated successfully!',
            'presentation_id': presentation_id
        })
    
    except Exception as e:
        logger.error(f"Complete presentation error: {str(e)}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/presentations/generate-pptx', methods=['POST'])
@login_required
def generate_pptx():
    """Generate the actual PowerPoint file"""
    try:
        from pptx_generator import generate_presentation
        from flask import send_file
        import tempfile
        
        data = request.json
        title = data.get('title', 'Presentation')
        topic = data.get('topic', '')
        sections = data.get('sections', [])
        theme = data.get('theme', 'Business Black and Yellow')
        notes_style = data.get('notesStyle', 'Detailed')
        
        # Generate presentation in temp file
        with tempfile.NamedTemporaryFile(delete=False, suffix='.pptx') as tmp:
            filename = generate_presentation(
                title=title,
                topic=topic,
                sections=sections,
                theme_name=theme,
                notes_style=notes_style,
                filename=tmp.name
            )
            
            # Send file
            return send_file(
                filename,
                mimetype='application/vnd.openxmlformats-officedocument.presentationml.presentation',
                as_attachment=True,
                download_name=f"{title.replace(' ', '_')}.pptx"
            )
    
    except Exception as e:
        logger.error(f"PPTX generation error: {str(e)}")
        return jsonify({'error': str(e)}), 500

# ============= Utility Endpoints =============

@app.route('/health', methods=['GET'])
def health_check():
    """Health check endpoint"""
    return jsonify({
        'status': 'healthy',
        'timestamp': datetime.now().isoformat(),
        'api_configured': bool(ANTHROPIC_API_KEY)
    })

@app.route('/api/test', methods=['POST'])
def test_api():
    """Test endpoint to verify API key works"""
    try:
        response = call_anthropic("Test", max_tokens=10)
        return jsonify({'success': True, 'message': 'API key is working'})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

if __name__ == '__main__':
    if not ANTHROPIC_API_KEY:
        print("⚠️  WARNING: ANTHROPIC_API_KEY environment variable is not set!")
        print("Set it with: export ANTHROPIC_API_KEY='your-key-here'")
    else:
        print("✓ API key configured")
    
    print("✓ Database initialized")
    print("✓ Authentication system ready")
    print("✓ Subscription system ready (1 free, then $9.99/month for 10 generations)")
    
    # For local development
    port = int(os.environ.get('PORT', 5000))
    app.run(host='0.0.0.0', port=port, debug=True)
